---
Title: ' ガジェットクラス名の不可解な現象'
Category:
- GWT
Date: 2010-11-15T20:17:07+09:00
URL: http://tkatochin.hatenablog.com/entry/20101115/1289819827
EditURL: https://blog.hatena.ne.jp/t-katochin/tkatochin.hatenablog.com/atom/entry/6653586347154753235
---

　GWT-Gadgetの拡張ライブラリを作成しているんだけど、そのライブラリを使って新たなガジェットを作成すると、GWTコンパイルは通るのに、コードが埋め込まれないという現象が。コードが埋め込まれる場所には[ __BOOTSTRAP__]とあるだけ。
しかし、新たなガジェットのクラス名によっては展開される事も。
気になっていろいろ検証した結果、ライブラリのEntryPointのクラス名よりアルファベット順が若いクラス名をEntryPointにすると正常に生成され、そうでないと正しくコードが出力されないということが分かった。
作っていたのはOAuthGadgetというクラス名だった。新しいガジェットクラス名が、OAuthGadgesまでは正常にコードが吐かれ、OAuthGadgeu以降ではコードが吐かれない。しかも何もエラーにならない。

なんでこうなるのか意味が分からない（ビルドプロセス、丹念に追えば分かるのかもしれないけど気力無し）。とりあえずの回避策として、ZZZZというクラス名にした。あー気持ち悪い。

どうも、ビルド出力先には、OAuthGadget.gadget.xmlと、新たなクラス名.gadget.xmlが出力されてしまう事が原因な気がする。普通、GWTやGadgetの元のエントリーポイントは出力先には吐き出されないが、ライブラリを作成しようとしてもビルド時に実行可能なエントリーポイントの作成を強要される（普通のGWTビルドのせいかもしれない。ライブラリのビルド方法があるのかな？）ので、仕方なく OAuthGadgetというクラスを用意した。するとコードの埋め込み先の検索が、*.gadget.xmlの中に定義されているエントリーポイントのクラス名が若い方に入ってしまうようだ。コードが埋め込まれない時は、横にあるOAuthGadget.gadget.xml内にコードが埋め込まれるということが分かった。

うーん、拡張ライブラリの正しい作り方が知りたい。。。とはいえ、gwt.Gadgetをinheritesしないと、その中のクラスを参照できないし、けれどもそうするとgwt.Gadgetを継承したentryPointの作成が要求されるので、ゴミな .gadget.xml が出来てしまうのは構成上どうしようもなくなっているだけで、良い手は無いのかもしれない。gwt-gadgetを再構築でもしない限り。
１つのgwt.xmlで一緒くたに持っちゃっているからいけないんだよね。多分。rpcのRedirectorを差し替えたいだけなんだけどね。

***追記
　拡張ライブラリの正しい作り方は、結局ライブラリ開発用のプロジェクト上ではGWTコンパイルを掛けなければ良いということだった。クライアントのJavaソースを同梱したjarを生成し、利用側のプロジェクトで参照して、利用側のプロジェクト内でGWTコンパイルを掛けるということだった。これでようやく拡張ライブラリモジュールにエントリーポイントがなくても怒られなくなる。
